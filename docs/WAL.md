# WAL.md — Write-Ahead Log (Журнал решений)

## Назначение
Этот файл фиксирует **решения**, принятые в ходе разработки, а не только факты.
Служит для сохранения контекста между сессиями AI-сопроцессора.

---

## [2026-02-26] Инициализация проекта

### Контекст
Проект `jwl-backup-merger` существует, но не соответствует протоколу из `ai_rules.md`:
- Отсутствуют BOOT.md и WAL.md
- Нет формальных спецификаций `spec://`
- Документация разрознена

### Принятые решения

#### 1. Структура документации
**Решение**: Создать иерархию документов по протоколу:
- `docs/BOOT.md` — инструкции загрузки контекста
- `docs/WAL.md` — журнал решений (этот файл)
- `docs/specs/` — формальные спецификации

**Обоснование**: Требуется протоколом `ai_rules.md` для stateless-архитектуры.

#### 2. Анализ проекта проведён
**Решение**: Зафиксировать плюсы и минусы текущего состояния.

**Плюсы**:
- Модульная архитектура
- Умная дедупликация на SHA-256
- Правильный порядок таблиц (родительские → дочерние)
- Маппинг ID для связанных записей
- Транзакции с rollback
- Покрытие тестами ключевых функций

**Минусы**:
- Нет спецификаций `spec://`
- Нет BOOT.md / WAL.md (исправляется сейчас)
- Нет тестов на коллизии хэшей
- Слабая валидация схемы перед слиянием
- Нет версионирования схемы JW Library
- Нет CI/CD workflows

#### 3. План модернизации
**Решение**: Создать спецификации для всех компонентов.

**Созданные спецификации**:

| Spec | Компонент | Статус |
|------|-----------|--------|
| `spec://core/hash` | Генерация хэшей | ✅ Создана |
| `spec://core/archive` | Работа с архивами | ✅ Создана |
| `spec://core/schema` | Валидация схемы | ✅ Создана |
| `spec://core/merger` | Слияние записей | ✅ Создана |
| `spec://core/manifest` | Манифест | ✅ Создана |
| `spec://test/hash-generation` | Тесты хэшей | ✅ Создана |
| `spec://test/integration` | Интеграционные тесты | ✅ Создана |
| `spec://cli/interface` | CLI | ✅ Создана |

**Обоснование**: Протокол требует ссылку `spec://...` для каждого изменения кода.

---

## [2026-02-26] Создана документация

### Контекст
Требуется создать BOOT.md и WAL.md по протоколу.

### Решение
**Созданы файлы**:
- `docs/BOOT.md` — инструкции загрузки, архитектура, компоненты
- `docs/WAL.md` — этот журнал

**Обоснование**: Соответствует протоколу `ai_rules.md#BOOT-протокол`.

---

## Текущий статус

| Задача | Статус |
|--------|--------|
| Анализ проекта | ✅ Завершено |
| Создание BOOT.md | ✅ Завершено |
| Создание WAL.md | ✅ Завершено |
| Создание спецификаций | ✅ Завершено |
| Исправление минусов | ⏳ Ожидает |

---

## Активные задачи

1. **Создание спецификаций** `spec://` для всех компонентов ✅ ЗАВЕРШЕНО
2. **Добавление тестов на коллизии хэшей** (spec://core/hash#collision-tests)
3. **Улучшение валидации схемы** (spec://core/schema#validation)
4. **Добавление CI/CD** (spec://ci/github-actions) ✅ ЗАВЕРШЕНО

---

## [2026-02-26] Исправление тестов и сборки

### Контекст
2 теста проваливались:
- `test_copy_tags` — ожидалось 3 тега, получено 2
- `test_id_mapping_created` — маппинг ID не создавался

### Причина
Функция `copy_unique_records()` включала первичный ключ (PK) в SQL INSERT:
```sql
INSERT OR IGNORE INTO "Tag" ("TagId", "Name", "Type") VALUES (?, ?, ?)
```

При вставке тега с `TagId=1` в целевую БД, где уже есть запись с `TagId=1`,
возникал конфликт уникальности. `INSERT OR IGNORE` игнорировал запись вместо
вставки с новым ID.

### Решение
Исключить первичный ключ из INSERT, чтобы SQLite автоматически назначал новые ID:

```python
if pk_column and pk_column in columns:
    pk_index = columns.index(pk_column)
    insert_columns = [col for col in columns if col != pk_column]
    insert_record = record[:pk_index] + record[pk_index + 1:]
```

**Обоснование**: Это позволяет избежать конфликтов PK и обеспечивает корректный
маппинг ID между исходной и целевой БД.

**Ссылка**: spec://core/merger#copy_unique_records

---

## [2026-02-26] Исправление CI/CD workflow

### Контекст
GitHub Actions workflow `build.yml` имел проблемы:
1. Использовался сторонний экшен `JackMcKew/pyinstaller-action-windows@main`
   для Windows-сборки — ненадёжная зависимость
2. Смешанные job'ы для release и обычных сборок
3. Неправильные пути к артефактам

### Решение
Разделить job'ы по платформам:
- `build-linux` — Ubuntu
- `build-windows` — Windows (нативная сборка через pyinstaller)
- `build-macos` — macOS

Убрать зависимость от сторонних экшенов. Все платформы собираются нативно.

**Ссылка**: spec://ci/github-actions (требуется создание)

---

## [2026-02-26] Исправление извлечения БД с разным именем файла

### Контекст
Бэкапы с iPad используют имя файла `user_data.db` (с подчёркиванием), а не `userData.db`.
Функция `extract_from_archive()` корректно возвращала путь к БД, но в `create_merged_db()`
путь игнорировался и использовалось жёстко заданное имя.

### Проблема
```python
# БЫЛО (неверно):
_, _ = extract_from_archive(first_archive, temp_dir)
first_db_path = Path(temp_dir) / 'userData.db'  # Игнорирование возвращённого пути
```

### Решение
Использовать возвращённый путь из функции:
```python
# СТАЛО (верно):
first_db_path, _ = extract_from_archive(first_archive, temp_dir)
shutil.copyfile(first_db_path, output_path)
```

**Обоснование**: `extract_from_archive()` возвращает кортеж `(db_path, manifest_path)`,
где `db_path` — это фактический путь к БД (может быть `userData.db` или `user_data.db`).

**Ссылка**: spec://core/archive#extract_from_archive

**Тестирование**:
- Alenka.jwlibrary (iPad, user_data.db): ✅ 23,451 UserMark, 2,082 Note (100% добавлено)
- Все 28 unit-тестов: ✅ passed
- Интеграционный тест: ✅ 4 архива → 143,831 записей

---

## [2026-02-26] Полный отчёт об объединении

### Статистика слияния (4 архива)

| Архив | Note | UserMark | Location | Уникальные Guid |
|-------|------|----------|----------|-----------------|
| Alenka (iPad) | 2,082 | 23,451 | 2,034 | 23,451 (100%) |
| DESKTOP-PDFDOOU | 1,755 | 23,519 | 3,839 | 0 (0%) |
| Xiaomi | 1,802 | 27,756 | 4,284 | 4,249 (15.3%) |
| Samsung | 1,756 | 23,845 | 3,868 | 332 (1.4%) |
| **Сумма** | **7,395** | **98,571** | **14,025** | — |
| **Результат** | **3,922** | **51,551** | **7,794** | — |
| **Дедупликация** | 47% | 47.7% | 44.4% | — |

### Выводы
- **Alenka**: все данные уникальны и добавлены (100%)
- **DESKTOP-PDFDOOU**: все данные дублируются в других архивах (0% уникальных)
- **Xiaomi/Samsung**: частичное перекрытие (15.3% и 1.4% уникальных)
- **Итого**: 143,831 запись в объединённом архиве

---

## [2026-02-26] Добавлен графический интерфейс (GUI)

### Контекст
Пользователям требуется простой способ использования без командной строки.

### Решение
Создан графический интерфейс на tkinter (кроссплатформенно):

**Файлы**:
- `jwl_backup_merger_gui.py` — основной код GUI
- `jwl_backup_merger_gui.spec` — spec для PyInstaller
- `docs/specs/gui-interface.md` — спецификация

**Функционал**:
1. Выбор папки с бэкапами (кнопка "Обзор")
2. Отображение списка найденных архивов
3. Выбор выходного файла
4. Кнопка "Объединить" с прогресс-баром
5. Опция открытия папки после завершения

**Сборка**:
- CLI: `jwl-backup-merger-cli-*` (консольная версия)
- GUI: `jwl-backup-merger-gui-*` (графическая версия)

**Workflow обновлён**:
- `build-cli-*` — сборка CLI для Linux/Windows/macOS
- `build-gui-*` — сборка GUI для Linux/Windows/macOS
- `publish-release` — загрузка 6 бинарников в релиз

**Спецификация**: spec://gui/interface

---

*Последнее обновление: 2026-02-26*
