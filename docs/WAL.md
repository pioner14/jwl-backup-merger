# WAL.md — Write-Ahead Log (Журнал решений)

## Назначение
Этот файл фиксирует **решения**, принятые в ходе разработки, а не только факты.
Служит для сохранения контекста между сессиями AI-сопроцессора.

---

## [2026-02-26] Инициализация проекта

### Контекст
Проект `jwl-backup-merger` существует, но не соответствует протоколу из `ai_rules.md`:
- Отсутствуют BOOT.md и WAL.md
- Нет формальных спецификаций `spec://`
- Документация разрознена

### Принятые решения

#### 1. Структура документации
**Решение**: Создать иерархию документов по протоколу:
- `docs/BOOT.md` — инструкции загрузки контекста
- `docs/WAL.md` — журнал решений (этот файл)
- `docs/specs/` — формальные спецификации

**Обоснование**: Требуется протоколом `ai_rules.md` для stateless-архитектуры.

#### 2. Анализ проекта проведён
**Решение**: Зафиксировать плюсы и минусы текущего состояния.

**Плюсы**:
- Модульная архитектура
- Умная дедупликация на SHA-256
- Правильный порядок таблиц (родительские → дочерние)
- Маппинг ID для связанных записей
- Транзакции с rollback
- Покрытие тестами ключевых функций

**Минусы**:
- Нет спецификаций `spec://`
- Нет BOOT.md / WAL.md (исправляется сейчас)
- Нет тестов на коллизии хэшей
- Слабая валидация схемы перед слиянием
- Нет версионирования схемы JW Library
- Нет CI/CD workflows

#### 3. План модернизации
**Решение**: Создать спецификации для всех компонентов.

**Созданные спецификации**:

| Spec | Компонент | Статус |
|------|-----------|--------|
| `spec://core/hash` | Генерация хэшей | ✅ Создана |
| `spec://core/archive` | Работа с архивами | ✅ Создана |
| `spec://core/schema` | Валидация схемы | ✅ Создана |
| `spec://core/merger` | Слияние записей | ✅ Создана |
| `spec://core/manifest` | Манифест | ✅ Создана |
| `spec://test/hash-generation` | Тесты хэшей | ✅ Создана |
| `spec://test/integration` | Интеграционные тесты | ✅ Создана |
| `spec://cli/interface` | CLI | ✅ Создана |

**Обоснование**: Протокол требует ссылку `spec://...` для каждого изменения кода.

---

## [2026-02-26] Создана документация

### Контекст
Требуется создать BOOT.md и WAL.md по протоколу.

### Решение
**Созданы файлы**:
- `docs/BOOT.md` — инструкции загрузки, архитектура, компоненты
- `docs/WAL.md` — этот журнал

**Обоснование**: Соответствует протоколу `ai_rules.md#BOOT-протокол`.

---

## Текущий статус

| Задача | Статус |
|--------|--------|
| Анализ проекта | ✅ Завершено |
| Создание BOOT.md | ✅ Завершено |
| Создание WAL.md | ✅ Завершено |
| Создание спецификаций | ✅ Завершено |
| Исправление минусов | ⏳ Ожидает |

---

## Активные задачи

1. **Создание спецификаций** `spec://` для всех компонентов ✅ ЗАВЕРШЕНО
2. **Добавление тестов на коллизии хэшей** (spec://core/hash#collision-tests)
3. **Улучшение валидации схемы** (spec://core/schema#validation)
4. **Добавление CI/CD** (spec://ci/github-actions) ✅ ЗАВЕРШЕНО

---

## [2026-02-26] Исправление тестов и сборки

### Контекст
2 теста проваливались:
- `test_copy_tags` — ожидалось 3 тега, получено 2
- `test_id_mapping_created` — маппинг ID не создавался

### Причина
Функция `copy_unique_records()` включала первичный ключ (PK) в SQL INSERT:
```sql
INSERT OR IGNORE INTO "Tag" ("TagId", "Name", "Type") VALUES (?, ?, ?)
```

При вставке тега с `TagId=1` в целевую БД, где уже есть запись с `TagId=1`,
возникал конфликт уникальности. `INSERT OR IGNORE` игнорировал запись вместо
вставки с новым ID.

### Решение
Исключить первичный ключ из INSERT, чтобы SQLite автоматически назначал новые ID:

```python
if pk_column and pk_column in columns:
    pk_index = columns.index(pk_column)
    insert_columns = [col for col in columns if col != pk_column]
    insert_record = record[:pk_index] + record[pk_index + 1:]
```

**Обоснование**: Это позволяет избежать конфликтов PK и обеспечивает корректный
маппинг ID между исходной и целевой БД.

**Ссылка**: spec://core/merger#copy_unique_records

---

## [2026-02-26] Исправление CI/CD workflow

### Контекст
GitHub Actions workflow `build.yml` имел проблемы:
1. Использовался сторонний экшен `JackMcKew/pyinstaller-action-windows@main`
   для Windows-сборки — ненадёжная зависимость
2. Смешанные job'ы для release и обычных сборок
3. Неправильные пути к артефактам

### Решение
Разделить job'ы по платформам:
- `build-linux` — Ubuntu
- `build-windows` — Windows (нативная сборка через pyinstaller)
- `build-macos` — macOS

Убрать зависимость от сторонних экшенов. Все платформы собираются нативно.

**Ссылка**: spec://ci/github-actions (требуется создание)

---

## [2026-02-26] Исправление извлечения БД с разным именем файла

### Контекст
Бэкапы с iPad используют имя файла `user_data.db` (с подчёркиванием), а не `userData.db`.
Функция `extract_from_archive()` корректно возвращала путь к БД, но в `create_merged_db()`
путь игнорировался и использовалось жёстко заданное имя.

### Проблема
```python
# БЫЛО (неверно):
_, _ = extract_from_archive(first_archive, temp_dir)
first_db_path = Path(temp_dir) / 'userData.db'  # Игнорирование возвращённого пути
```

### Решение
Использовать возвращённый путь из функции:
```python
# СТАЛО (верно):
first_db_path, _ = extract_from_archive(first_archive, temp_dir)
shutil.copyfile(first_db_path, output_path)
```

**Обоснование**: `extract_from_archive()` возвращает кортеж `(db_path, manifest_path)`,
где `db_path` — это фактический путь к БД (может быть `userData.db` или `user_data.db`).

**Ссылка**: spec://core/archive#extract_from_archive

**Тестирование**:
- Alenka.jwlibrary (iPad, user_data.db): ✅ 3922 Note, 51551 UserMark
- Все 28 unit-тестов: ✅ passed

---

*Последнее обновление: 2026-02-26*
